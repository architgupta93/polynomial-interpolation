classdef dctObj2D < dctObj2DInterpolant
    properties
        extrap_range = [];
    end
    
    methods
        function Obj = dctObj2D(init_val, range_x, range_y, extrap_range)
            Obj = Obj@dctObj2DInterpolant(init_val, range_x, range_y);
            if (nargin == 0)
                Obj.extrap_range = [-Inf Inf; ...
                                    -Inf Inf]
            else
                if (nargin < 4)
                    Obj.extrap_range = cat(1, range_x, range_y);
                else
                    Obj.extrap_range = extrap_range;
                end
            end
        end

        function [vq_calc, dvq_dx_calc, dvq_dy_calc] = evaluate(Obj, xq, yq)
            right_of_left_x = (xq >= Obj.extrap_range(1,1));
            left_of_right_x = (xq <= Obj.extrap_range(1,2));
            in_x =  right_of_left_x && left_of_right_x;

            right_of_left_y = (yq >= Obj.extrap_range(2,1));
            left_of_right_y = (yq <= Obj.extrap_range(2,2));
            in_y =  right_of_left_y && left_of_right_y;

            % We will essentially decompose the function into a tensor
            % product and evalute the two different terms (in x and y)
            % separately
            f_x = cell(Obj.n_dims);
            f_y = cell(Obj.n_dims);
            dfx_dx = cell(Obj.n_dims);
            dfy_dy = cell(Obj.n_dims);

            % Now comes the dirty part
            if (~in_x)
                if (~right_of_left_x)
                    index_x = Obj.findXIndex(Obj.extrap_range(1,1));
                    extrap_source = Obj.extrap_range(1,1);
                else
                    index_x = Obj.findXIndex(Obj.extrap_range(1,2));
                    extrap_source = Obj.extrap_range(1,2);
                end
                % Linear extrapolation from the point "extrap_source", with
                % the x-slope at extrap_source (indexed by index_x)
                for dim_index = 1:Obj.n_dims
                    dfx_dx{dim_index} = - (Obj.n_samples(1) - 1) * ...
                        Obj.non_zero_freqs_x{dim_index} .* ...
                        sin ( ...
                                Obj.non_zero_freqs_x{dim_index} * (index_x + 0.5) ...
                            ) / Obj.range_x;
                    f_x{dim_index} = ...
                        cos ( ...
                                Obj.non_zero_freqs_x{dim_index} * (index_x + 0.5) ...
                            ) + ... % Offset value, i.e. value at the extrap_source
                        dfx_dx{dim_index} * (xq - extrap_source);  % Ensures both continuity and differentiability at the boundary
                end
            else
                index_x = Obj.findXIndex(xq);
                for dim_index = 1:Obj.n_dims
                    dfx_dx{dim_index} = - (Obj.n_samples(1) - 1) * ...
                        Obj.non_zero_freqs_x{dim_index} .* ...
                        sin ( ...
                                Obj.non_zero_freqs_x{dim_index} * (index_x + 0.5) ...
                            ) / Obj.range_x;
                    f_x{dim_index} = ...
                        cos ( ...
                                Obj.non_zero_freqs_x{dim_index} * (index_x + 0.5) ...
                            );
                end
            end

            if (~in_y)
                if (~right_of_left_y)
                    index_y = Obj.findYIndex(Obj.extrap_range(2,1));
                    extrap_source = Obj.extrap_range(2,1);
                else
                    index_y = Obj.findYIndex(Obj.extrap_range(2,2));
                    extrap_source = Obj.extrap_range(2,2);
                end
                for dim_index = 1:Obj.n_dims
                    dfy_dy{dim_index} = - (Obj.n_samples(2) - 1) * ... 
                        Obj.non_zero_freqs_y{dim_index} .* ...
                        sin ( ...
                                Obj.non_zero_freqs_y{dim_index} * (index_y + 0.5) ...
                            ) / Obj.range_y;
                    f_y{dim_index} = ...
                        cos ( ...
                                Obj.non_zero_freqs_y{dim_index} * (index_y + 0.5) ...
                            ) + ...
                        dfy_dy{dim_index} * (yq - extrap_source);
                end
            else
                index_y = Obj.findYIndex(yq);
                for dim_index = 1:Obj.n_dims
                    dfy_dy{dim_index} = - (Obj.n_samples(2) - 1) * ...
                        Obj.non_zero_freqs_y{dim_index} .* ...
                        sin ( ...
                                Obj.non_zero_freqs_y{dim_index} * (index_y + 0.5) ...
                            ) / Obj.range_y;
                    f_y{dim_index} = ...
                        cos ( ...
                                Obj.non_zero_freqs_y{dim_index} * (index_y + 0.5) ...
                            );
                end
            end

            vq_calc = zeros(Obj.n_dims, 1);
            dvq_dx_calc = zeros(Obj.n_dims, 1);
            dvq_dy_calc = zeros(Obj.n_dims, 1);

            for dim_index = 1:Obj.n_dims
               vq_calc(dim_index, 1) =  sum ( ...
                                        sum ( ...
                                                Obj.coeffs{dim_index} .* f_x{dim_index} .* f_y{dim_index} ...
                                            ) ...
                                            ); 
               dvq_dx_calc(dim_index, 1) =  sum ( ...
                                            sum ( ...
                                                    Obj.coeffs{dim_index} .* dfx_dx{dim_index} .* f_y{dim_index} ...
                                                ) ...
                                                );
                                                
               dvq_dy_calc(dim_index, 1) =  sum ( ...
                                            sum ( ...
                                                    Obj.coeffs{dim_index} .* f_x{dim_index} .* dfy_dy{dim_index} ...
                                                ) ...
                                                );
            end
        end
    end
end
